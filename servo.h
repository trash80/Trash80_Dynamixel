#ifndef __TRASH80_DYNAMIXEL_SERVO__
#define __TRASH80_DYNAMIXEL_SERVO__

#include "dynamixeldevice.h"

__TRASH80_DYNAMIXEL_NAMESPACE_BEGIN__
class Servo : public Device {
    public:
        typedef enum
        {
            MODEL_NUMBER           = 0,    // Model Number
            MODEL_INFORMATION      = 2,    // Model Information
            FIRMWARE_VERSION       = 6,    // Firmware Version
            ID                     = 7,    // Dynamixel ID
            BAUD_RATE              = 8,    // Communication Baud Rate
            RETURN_DELAY_TIME      = 9,    // Response Delay Time
            DRIVE_MODE             = 10,   // Drive Mode
            OPERATING_MODE         = 11,   // Operating Mode
            SHADOW_ID              = 12,   // Secondary(Shadow) ID
            PROTOCOL_VERSION       = 13,   // Protocol Version
            HOMING_OFFSET          = 20,   // Home Position Offset
            MOVING_THRESHOLD       = 24,   // Velocity Threshold for Movement Detection
            TEMPERATURE_LIMIT      = 31,   // Maximum Internal Temperature Limit
            MAX_VOLTAGE_LIMIT      = 32,   // Maximum Voltage Limit
            MIN_VOLTAGE_LIMIT      = 34,   // Minimum Voltage Limit
            PWM_LIMIT              = 36,   // Maximum PWM Limit
            CURRENT_LIMIT          = 38,   // Maximum Current Limit
            ACCELERATION_LIMIT     = 40,   // Maximum Acceleration Limit
            VELOCITY_LIMIT         = 44,   // Maximum Velocity Limit
            MAX_POSITION_LIMIT     = 48,   // Maximum Position Limit
            MIN_POSITION_LIMIT     = 52,   // Minimum Position Limit
            SHUTDOWN               = 63,   // Shutdown Dynamixel
            TORQUE_ENABLE          = 64,   // Motor Torque On/Off
            LED                    = 65,   // Status LED On/Off
            STATUS_RETURN_LEVEL    = 68,   // Select Types of Status Return
            REGISTERED_INSTRUCTION = 69,   // Check Reception of Instruction
            HARDWARE_ERROR_STATUS  = 70,   // Hardware Error Status
            VELOCITY_I_GAIN        = 76,   // I Gain of Velocity
            VELOCITY_P_GAIN        = 78,   // P Gain of Velocity
            POSITION_D_GAIN        = 80,   // D Gain of Position
            POSITION_I_GAIN        = 82,   // I Gain of Position
            POSITION_P_GAIN        = 84,   // P Gain of Position
            FEEDFORWARD_2ND_GAIN   = 88,   // 2nd Gain of Feed-Forward
            FEEDFORWARD_1ST_GAIN   = 90,   // 1st Gain of Feed-Forward
            BUS_WATCHDOG           = 98,   // Dynamixel Bus Watchdog
            GOAL_PWM               = 100,  // Target PWM Value
            GOAL_CURRENT           = 102,  // Target Current Value
            GOAL_VELOCITY          = 104,  // Target Velocity Value
            PROFILE_ACCELERATION   = 108,  // Acceleration Value of Profile
            PROFILE_VELOCITY       = 112,  // Velocity Value of Profile
            GOAL_POSITION          = 116,  // Target Position Value
            REALTIME_TICK          = 120,  // Count Time in millisecond
            MOVING                 = 122,  // Movement Status
            MOVING_STATUS          = 123,  // Detailed Information of Movement Status
            PRESENT_PWM            = 124,  // Current PWM Value
            PRESENT_CURRENT        = 126,  // Current Current Value
            PRESENT_VELOCITY       = 128,  // Current Velocity Value
            PRESENT_POSITION       = 132,  // Current Position Value
            VELOCITY_TRAJECTORY    = 136,  // Target Velocity Trajectory Generated by Profile
            POSITION_TRAJECTORY    = 140,  // Target Position Trajectory Generated by Profile
            PRESENT_INPUT_VOLTAGE  = 144,  // Current Input Voltage
            PRESENT_TEMPERATURE    = 146   // Current Internal Temperature
        } CONTROL_ADDRESS;

        // Generated by control_table.js
        uint16_t getModelNumber(){ return getValue((uint16_t)MODEL_NUMBER, 2); };
        uint32_t getModelInformation(){ return getValue((uint16_t)MODEL_INFORMATION, 4); };
        uint8_t getFirmwareVersion(){ return getValue((uint16_t)FIRMWARE_VERSION, 1); };
        uint8_t getId(){ return getValue((uint16_t)ID, 1); };
        uint8_t getBaudRate(){ return getValue((uint16_t)BAUD_RATE, 1); };
        uint8_t getReturnDelayTime(){ return getValue((uint16_t)RETURN_DELAY_TIME, 1); };
        uint8_t getDriveMode(){ return getValue((uint16_t)DRIVE_MODE, 1); };
        uint8_t getOperatingMode(){ return getValue((uint16_t)OPERATING_MODE, 1); };
        uint8_t getShadowId(){ return getValue((uint16_t)SHADOW_ID, 1); };
        uint8_t getProtocolVersion(){ return getValue((uint16_t)PROTOCOL_VERSION, 1); };
        uint32_t getHomingOffset(){ return getValue((uint16_t)HOMING_OFFSET, 4); };
        uint32_t getMovingThreshold(){ return getValue((uint16_t)MOVING_THRESHOLD, 4); };
        uint8_t getTemperatureLimit(){ return getValue((uint16_t)TEMPERATURE_LIMIT, 1); };
        uint16_t getMaxVoltageLimit(){ return getValue((uint16_t)MAX_VOLTAGE_LIMIT, 2); };
        uint16_t getMinVoltageLimit(){ return getValue((uint16_t)MIN_VOLTAGE_LIMIT, 2); };
        uint16_t getPwmLimit(){ return getValue((uint16_t)PWM_LIMIT, 2); };
        uint16_t getCurrentLimit(){ return getValue((uint16_t)CURRENT_LIMIT, 2); };
        uint32_t getAccelerationLimit(){ return getValue((uint16_t)ACCELERATION_LIMIT, 4); };
        uint32_t getVelocityLimit(){ return getValue((uint16_t)VELOCITY_LIMIT, 4); };
        uint32_t getMaxPositionLimit(){ return getValue((uint16_t)MAX_POSITION_LIMIT, 4); };
        uint32_t getMinPositionLimit(){ return getValue((uint16_t)MIN_POSITION_LIMIT, 4); };
        uint8_t getShutdown(){ return getValue((uint16_t)SHUTDOWN, 1); };
        uint8_t getTorqueEnable(){ return getValue((uint16_t)TORQUE_ENABLE, 1); };
        uint8_t getLed(){ return getValue((uint16_t)LED, 1); };
        uint8_t getStatusReturnLevel(){ return getValue((uint16_t)STATUS_RETURN_LEVEL, 1); };
        uint8_t getRegisteredInstruction(){ return getValue((uint16_t)REGISTERED_INSTRUCTION, 1); };
        uint8_t getHardwareErrorStatus(){ return getValue((uint16_t)HARDWARE_ERROR_STATUS, 1); };
        uint16_t getVelocityIGain(){ return getValue((uint16_t)VELOCITY_I_GAIN, 2); };
        uint16_t getVelocityPGain(){ return getValue((uint16_t)VELOCITY_P_GAIN, 2); };
        uint16_t getPositionDGain(){ return getValue((uint16_t)POSITION_D_GAIN, 2); };
        uint16_t getPositionIGain(){ return getValue((uint16_t)POSITION_I_GAIN, 2); };
        uint16_t getPositionPGain(){ return getValue((uint16_t)POSITION_P_GAIN, 2); };
        uint16_t getFeedforward2ndGain(){ return getValue((uint16_t)FEEDFORWARD_2ND_GAIN, 2); };
        uint16_t getFeedforward1stGain(){ return getValue((uint16_t)FEEDFORWARD_1ST_GAIN, 2); };
        uint8_t getBusWatchdog(){ return getValue((uint16_t)BUS_WATCHDOG, 1); };
        uint16_t getGoalPwm(){ return getValue((uint16_t)GOAL_PWM, 2); };
        uint16_t getGoalCurrent(){ return getValue((uint16_t)GOAL_CURRENT, 2); };
        uint32_t getGoalVelocity(){ return getValue((uint16_t)GOAL_VELOCITY, 4); };
        uint32_t getProfileAcceleration(){ return getValue((uint16_t)PROFILE_ACCELERATION, 4); };
        uint32_t getProfileVelocity(){ return getValue((uint16_t)PROFILE_VELOCITY, 4); };
        uint32_t getGoalPosition(){ return getValue((uint16_t)GOAL_POSITION, 4); };
        uint16_t getRealtimeTick(){ return getValue((uint16_t)REALTIME_TICK, 2); };
        uint8_t getMoving(){ return getValue((uint16_t)MOVING, 1); };
        uint8_t getMovingStatus(){ return getValue((uint16_t)MOVING_STATUS, 1); };
        uint16_t getPresentPwm(){ return getValue((uint16_t)PRESENT_PWM, 2); };
        uint16_t getPresentCurrent(){ return getValue((uint16_t)PRESENT_CURRENT, 2); };
        uint32_t getPresentVelocity(){ return getValue((uint16_t)PRESENT_VELOCITY, 4); };
        uint32_t getPresentPosition(){ return getValue((uint16_t)PRESENT_POSITION, 4); };
        uint32_t getVelocityTrajectory(){ return getValue((uint16_t)VELOCITY_TRAJECTORY, 4); };
        uint32_t getPositionTrajectory(){ return getValue((uint16_t)POSITION_TRAJECTORY, 4); };
        uint16_t getPresentInputVoltage(){ return getValue((uint16_t)PRESENT_INPUT_VOLTAGE, 2); };
        uint8_t getPresentTemperature(){ return getValue((uint16_t)PRESENT_TEMPERATURE, 1); };

        bool setId(uint8_t value){ if(setValue(ID, value)) { id = value; return true;} return false; };
        bool setBaudRate(uint8_t value){ return setValue(BAUD_RATE, value); };
        bool setReturnDelayTime(uint8_t value){ return setValue(RETURN_DELAY_TIME, value); };
        bool setDriveMode(uint8_t value){ return setValue(DRIVE_MODE, value); };
        bool setOperatingMode(uint8_t value){ return setValue(OPERATING_MODE, value); };
        bool setShadowId(uint8_t value){ return setValue(SHADOW_ID, value); };
        bool setHomingOffset(uint32_t value){ return setValue(HOMING_OFFSET, value); };
        bool setMovingThreshold(uint32_t value){ return setValue(MOVING_THRESHOLD, value); };
        bool setTemperatureLimit(uint8_t value){ return setValue(TEMPERATURE_LIMIT, value); };
        bool setMaxVoltageLimit(uint16_t value){ return setValue(MAX_VOLTAGE_LIMIT, value); };
        bool setMinVoltageLimit(uint16_t value){ return setValue(MIN_VOLTAGE_LIMIT, value); };
        bool setPwmLimit(uint16_t value){ return setValue(PWM_LIMIT, value); };
        bool setCurrentLimit(uint16_t value){ return setValue(CURRENT_LIMIT, value); };
        bool setAccelerationLimit(uint32_t value){ return setValue(ACCELERATION_LIMIT, value); };
        bool setVelocityLimit(uint32_t value){ return setValue(VELOCITY_LIMIT, value); };
        bool setMaxPositionLimit(uint32_t value){ return setValue(MAX_POSITION_LIMIT, value); };
        bool setMinPositionLimit(uint32_t value){ return setValue(MIN_POSITION_LIMIT, value); };
        bool setShutdown(uint8_t value){ return setValue(SHUTDOWN, value); };
        bool setTorqueEnable(uint8_t value){ return setValue(TORQUE_ENABLE, value); };
        bool setLed(uint8_t value){ return setValue(LED, value); };
        bool setStatusReturnLevel(uint8_t value){ return setValue(STATUS_RETURN_LEVEL, value); };
        bool setVelocityIGain(uint16_t value){ return setValue(VELOCITY_I_GAIN, value); };
        bool setVelocityPGain(uint16_t value){ return setValue(VELOCITY_P_GAIN, value); };
        bool setPositionDGain(uint16_t value){ return setValue(POSITION_D_GAIN, value); };
        bool setPositionIGain(uint16_t value){ return setValue(POSITION_I_GAIN, value); };
        bool setPositionPGain(uint16_t value){ return setValue(POSITION_P_GAIN, value); };
        bool setFeedforward2ndGain(uint16_t value){ return setValue(FEEDFORWARD_2ND_GAIN, value); };
        bool setFeedforward1stGain(uint16_t value){ return setValue(FEEDFORWARD_1ST_GAIN, value); };
        bool setBusWatchdog(uint8_t value){ return setValue(BUS_WATCHDOG, value); };
        bool setGoalPwm(uint16_t value){ return setValue(GOAL_PWM, value); };
        bool setGoalCurrent(uint16_t value){ return setValue(GOAL_CURRENT, value); };
        bool setGoalVelocity(uint32_t value){ return setValue(GOAL_VELOCITY, value); };
        bool setProfileAcceleration(uint32_t value){ return setValue(PROFILE_ACCELERATION, value); };
        bool setProfileVelocity(uint32_t value){ return setValue(PROFILE_VELOCITY, value); };
        bool setGoalPosition(uint32_t value){ return setValue(GOAL_POSITION, value); };

        static const uint8_t addressSize(uint16_t address) {
            if(address > 146) return 0;
            //generated via memory_map.js
            static const uint8_t memory_map[147] = {
                2,0,4,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,0,1,2,0,2,0,2,0,2,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,0,1,0,2,0,2,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,2,0,1,1,2,0,2,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,2,0,1
            };
            return memory_map[address];
        }
};
__TRASH80_DYNAMIXEL_NAMESPACE_END__

#endif
